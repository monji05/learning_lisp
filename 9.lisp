; 9.1 配列
; arefは配列から要素を取り出したり入れたりするのに使う
; (make-array 3) => #(NIL NIL NIL)
; この例では長さ３の配列を作っている、先頭の#で配列はリストと区別される
(defparameter x (make-array 3))
; １番目の要素を取り出したいとき
(aref x 1)
; 値を配列にセットするにはarefをsetfコマンドと一緒に使う
(setf (aref x 1) 'foo)
; X => #(NIL FOO NIL)
; arefとsetfの組み合わせはジェネリックプログラミングと呼ばれるもの

; ジェネリックはセッター
; Common Lispはジェネリックなセッターをサポートしているといわれる、これは多くの場合データ構造（配列、リスト、文字列等々）から値を取り出すコードと、その構造に値をいれるコードが同じ形で書けるということだ

; 配列とリスト
; リストでできることはほとんどすべて配列でも実装できる、ただ、特定の要素にアクセスするのに配列はリストよりもずっと速い
; つまり両者の違いは性能にある
; 例えば配列を扱うarefはリストを扱うnthとよくにている
; nthは通常のリストの指定の場所をアクセスする関数だ
(nth 1 '(foo bar baz))
; nthが実用的に役に立つのは、リストの最初の方にアクセスする場合だけだ
; 数千個の要素を持っているリストxの1000番目の要素にアクセスするのはとても遅い
; Lispのリストはコンスセルの連鎖でできていて、1000番目の要素にたどり着く唯一の方法はそれに先立つ999個のセルを先頭から順繰りにたどっていくことだ
; これに対して大きな配列に(aref x 1000)とすると、1000番目の要素に直接アクセスできる
; その前の999個の要素を数え上げる必要はない、つまり大きな配列に対してarefコマンドを実行する方がずっと速い

; 9.2 ハッシュテーブル
; 配列とリストが似ていたのと同じような意味で、ハッシュテーブルはalistに似ている
; キーに結び付けられた値を取り出すのだがalistよりも速い
; ハッシュテーブルを使う
(make-hash-table)

(defparameter x (make-hash-table))

; コーヒーの注文を表現するデータ構造をハッシュテーブル
(defparameter *drink-order* (make-hash-table))
(setf (gethash 'bill *drink-order*) 'double-espresso)
(setf (gethash 'lisa *drink-order*) 'small-drip-coffee)
(setf (gethash 'john *drink-order*) 'medium-latte)

;誰が何を注文したのかを確かめるのは簡単だ
(gethash 'lisa *drink-order*)

; ハッシュテーブルの性能
; ハッシュテーブルの設計によりテーブルの要素の数にかかわらずアクセスにかかる時間は一定である
; GoogleのBigTableやAmazonのS3のような、最新のオンラインデータ用大規模ストレージシステムも、キーから対応する値を素早く取り出すために作られており、ハッシュテーブルと同じようなものとみなせる
; ただ、ハッシュテーブルがいつでも最速であるとは限らない、理由は以下
; 1. 仮想メモリとキャッシュミス
;    配列でも同じだが、大きなハッシュテーブルを使うとオペレーティングシステムが仮想メモリをハードディスクに読み書きし始め、性能が悪化する、同時にCPUのキャッシュミスもテーブルが大きいほうが増加する
; 2. ハッシュ値の衝突
;    内部的にハッシュテーブルはハッシュ関数という特別な関数を使ってキーを数値に変換している
;    ハッシュテーブルは衝突起きても正しく動作するように作られているが、速度は低下してしまう
;    稀にキーが特殊な分布をしている場合、ハッシュ関数によっては衝突が頻発して、アプリケーションが値を取り出す操作を遅くし、性能に悪影響を与える場合がある
; 3. 小さなテーブルの効率
;    テーブルがとても小さい場合、ハッシュテーブルを作ったりそこから値を検索したりするオーバヘッドがより簡単なalistのような構造に比べて効率を悪くしてしまう場合がある
;    ハッシュテーブルの利点はある程度以上のデータを格納する場合に活きてくる
; 4. 操作速度の不均一性
;    Common Lispで小さなハッシュテーブルを作り徐々に値を増やしていくと特定の点で新しい値を足すときに妙に長い時間がかかることがある
;    これはmake-hash-tableが小さなハッシュテーブルを作るのに最適化されているせいだ
;    値を増やし活きテーブルの大きさがある閾値を超えるとLispは追加のメモリをアロケートしてより多くのデータを格納できる形にテーブルを作り変えるが、それには時間がかかる
; ハッシュテーブルがいつでも最適なデータ構造とは限らない
; 簡単な指針として新しいコードを考え始めるときは配列やハッシュテーブルのことは考えないほうがいい
; 性能がボトルネックになっている部分を配列やハッシュテーブルを使うように書き換えて、性能を改善すればいい

; 9.3 構造体
; 構造体はCommon Lispが提供するより進んだデータ型
; いくつかの決まった属性をもつデータは構造体で表現するのが便利だ
; 構造体は典型的なオブジェクト指向プログラミング（OOP）のように属性を持つオブジェクトを表現するのに使われる
; 構造体を定義するにはdefstructコマンドをつかう
; この構造体の定義によればpersonは４つの属性（Lispふうに言えばスロット）をもつ
; name, age, waist-size(ウェストのサイズ),favorite-color(好みの色)
(defstruct person
           name
           age
           waist-size
           favorite-color
)
; この通り構造体を定義しておけば、personのインスタンスをmake-personコマンドで作ることができる
; make-personの定義はdefstructが自動的にやってくれる
; REPLに*bob*をタイプすれば、結果の構造体が#Sをつけた形で表示される
(defparameter *bob* (make-person :name "Bob"
                                 :age 35
                                 :waist-size 32
                                 :favorite-color "blue"
                    )
)
; ボブの年齢を得るには、person-age関数を呼べばいい、この関数もやはり自動的につくられる
; このアクセス関数はsetfといっしょに使ってボブの年齢を変更するのにも使える
(setf (person-age *bob*) 36)
; Lispのリーダはpersonの出力表記をそのまま読み込んで、personのインスタンスにすることができる
; defstructは構造体のインスタンスを作る関数や、属性へのアクセス関数をすべて自動的に作ってくれる、強力なコマンドである

; 構造体をいつ使うか
; 標準のリストを使い、personを定義することもできる、構造体を使う意味はなんだろう
; まず、リストで定義したときは正しい位置にアクセスする関数をたくさん書かなければならないし、それがバグの元になる
; BoBがpersonだとどうやって判断する？年齢は35だったか?通常のリストは属性を持つオブジェクトをうまく表現するには不向きなのだ
; リストでオブジェクトを表現する大きな問題は、オブジェクトの属性の値は途中で変わり得るということだ
; Lispのリストは一度作ったら変わらない
; mutableなオブジェクトと構造体は相性がいい

; 9.4 データをジェネリックに扱う
; シーケンスを使う
; 引数のデータ型によらず動作するコードを書く一番簡単な方法は、データ型のチェックを他の誰かにやってもらうこと
; Common Lispのライブラリにはもともと様々なデータ型を受け取ってジェネリックな処理をする関数が揃っている
; 最もよく使われるジェネリック関数はシーケンス関数だ
; シーケンス関数はLispで値の列（シーケンス）を表す3つの主要なデータ型、リスト、配列、文字列を統一的に扱うことができる
; 実はシーケンス関数の一つをすでにそれと知らずに使っていた、length関数だ
; この関数は3種すべてのシーケンス型に対してその長さを調べるのに使える
(length '(a b c))
; => 3
(length "blub")
; => 4
(length (make-array 5))
; => 5
; ジェネリックなlength関数がないと、文字列の長さ、配列の長さ、リストの長さを知るのにそれぞれ別の関数を使う羽目になっていた

; 探索のためのシーケンス関数
; シーケンス関数の中には、シーケンスから何かを探し出すためのものがいくつかある