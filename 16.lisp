; 16 マクロの魔法
; 簡単なLispマクロ
; let のカッコは視覚的ノイズの一例だ
; letコマンドは特殊形式コマンドの一つで、他の関数ではできない
(defun add (a b)
    (let ((x (+ a b)))
        (format t "The sum is ~a" x)
        x)
)
; しかし、そのカッコはマクロを使えば余分なカッコを消せる
; マクロはどんなふうに変換されるか
; defmacro呼び出しの最初の行は「let1で始まるコードがあったら、それを標準的なLispに変換数方法をこれから記述するよ」とマクロ展開器に伝えている
; defmacroはまたマクロに渡される引数についても定義している
; マクロの引数には次の3つの引数を受け取ることになる
; var,val,bodyだ
; var: 最初の引数はローカル変数として定義される名前だ、マクロの中では引数varの値がその名前になっている今回の例ではシンボルfooだ
; val: 2番目の式はローカル変数(var)の値を決める 今回は(+ 2 3)になっている
; body: 3番目の式はlet1の中で実行されるコードの本体だ
; このコードの中ではet1が作る新しい変数（foo）を使うことができる
; マクロではこのコードが引数bodyの値として使える
; letコマンドは本体の中に複数の式を書いておくことができるから、let1も同じように使えるといい
; 最後のbody引数の前に特別なシンボル&bodyが置かれているのはそのため
(defmacro let1 (var val &body body)
    `(let ((,var ,val))
    ,@body
    )
)
; letとlet1のカッコの数を比較してみる
(let ((foo (+ 2 3)))
    (* foo foo)
    )

(let1 foo (+ 2 3)
    (* foo foo)
)

; マクロの展開
; マクロは関数が実行されるのとは異なるタイミングで実行される
; 通常のLisp関数はその関数を含むプログラムを実行するときに走る、このタイミングは「実行時」と呼ばれる
; 一方マクロはプログラムが走る前、Lisp環境でプログラムが読み込まれてコンパイルされる時点で走る、このタイミングは「マクロ展開時」と呼ばれる

